tm_shape(highways_lonlat) +
tm_lines(col="black") +
tm_shape(sfhomes15_sp) +
tm_dots(col="totvalue", size=.25,
title = "San Francisco Property Values (2015)") +
tm_layout(inner.margins=c(.05, .2, .15, .05))
# bottom, left, top, right
tmap_mode('plot')
tm_shape(sfboundary_lonlat) +
tm_polygons(col="beige", border.col="black") +
tm_shape(highways_lonlat) +
tm_lines(col="black") +
tm_shape(sfhomes15_sp) +
tm_dots(col="totvalue", size=.25,
title = "San Francisco Property Values (2015)") +
tm_layout(inner.margins=c(.05, .2, .15, .05))
# bottom, left, top, right
tmap_mode("view")
tm_shape(sfboundary_lonlat) +
tm_polygons(col="beige", border.col="black") +
tm_shape(highways_lonlat) +
tm_lines(col="black") +
tm_shape(sfhomes15_sp) +
tm_dots(col="totvalue", size=.25, title = "San Francisco Property Values (2015)") +
tm_layout(inner.margins=c(.05, .2, .15, .05)) # bottom, left, top, right
# OR
#ttm()       # Toggle Tmap mode between "interactive" and "plot"
#last_map()  # display the last map
tm_shape(sfboundary_lonlat) +
tm_polygons(col="beige", border.col="black") +
tm_shape(highways_lonlat) +
tm_lines(col="black") +
tm_shape(sfhomes15_sp) +
tm_dots(col="totvalue", size=.25,
title = "San Francisco Property Values (2015)",
popup.vars=c("SalesYear","totvalue","NumBedrooms",
"NumBathrooms","AreaSquareFeet")) +
tm_layout(inner.margins=c(.05, .2, .15, .05)) # bottom, left, top, right
map1 <- last_map()
map1 # then display it
# bottom, left, top, right
map1
save_tmap(map1, "sf_properties_CURRENT.png", height=6) # Static image file with
save_tmap(map1, "sf_properties_CURRENT.html") # interactive web map
?`tmap-element
adasdsa
~``
````
?tmap-element
?tmap_element
?tmap-element
?"tmap-element"
?tmap-element
sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
# sfhomes15_utm <- spTransform(bart, CRS(proj4string(sfboundary)))
sfhomes15_utm@proj4string
#sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
sfhomes15_utm <- spTransform(bart, CRS(proj4string(sfboundary)))
#sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
sfhomes15_utm <- spTransform(bart, proj4string(sfboundary))
library(rgdal)
library(sp)
#sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
sfhomes15_utm <- spTransform(bart, proj4string(sfboundary))
#sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
sfhomes15_utm <- spTransform(arhomes15_sp, proj4string(sfboundary))
#sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
sfhomes15_utm <- spTransform(sfhomes15_sp, proj4string(sfboundary))
sfhomes15_utm@proj4string
sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
# OR
#sfhomes15_utm <- spTransform(sfhomes15_sp, proj4string(sfboundary))
coordinates(bart) <- c("X","Y")
proj4string(bart) <-  CRS("+init=epsg:4326")
bart_utm <- spTransform(bart, CRS(proj4string(sfboundary)))
proj4string(bart_utm)
proj4string(sfboundary)
proj4string(highways)
proj4string(sfhomes15_utm)
proj4string(bart_utm)
proj4string(sfboundary)
proj4string(highways)
proj4string(sfhomes15_utm)
#sfhomes15_utm <- spTransform(sfhomes15_sp, CRS("+init=epsg:26910"))
sfhomes15_utm <- spTransform(sfhomes15_sp, CRS(proj4string(sfboundary)))
# check
proj4string(sfhomes15_utm)
proj4string(sfboundary)
plot(sfboundary)
lines(highways, col='purple', lwd=4)
points(sfhomes15_utm)
plot(bart_utm, col="red", pch=15, add=T)
library(rgeos)
gArea(sfboundary)
gArea(sfboundary)
sfboundary@proj4string
proj4string(sfboundary) # to get the CRS units
gArea(sfboundary) / (1000 * 1000) # Convert to square KM
gLength(highways) / 1000 # in kilometers
gDistance(bart_utm[bart_utm$STATION == 'EMBARCADERO',],
bart_utm[bart_utm$STATION == 'POWELL STREET',]) /1000
em_xy = bart_utm[bart_utm$STATION == 'EMBARCADERO',]@coords
po_xy = bart_utm[bart_utm$STATION == 'POWELL STREET',]@coords
po_xy
po_xy
lines(c(em_xy[1], po_xy[1]), c(em_xy[2], po_xy[2]) )
?gDistance
dist2emb<- gDistance(bart_utm[bart_utm$STATION == 'EMBARCADERO',],
sfhomes15_utm, byid=TRUE) /1000
# check output
nrow(dist2emb)
nrow(sfhomes15_utm)
head(dist2emb)
dist2emb<- gDistance(bart_utm[bart_utm$STATION == 'EMBARCADERO',],
sfhomes15_utm, byid=FALSE) /1000
# check output
nrow(dist2emb)
nrow(sfhomes15_utm)
head(dist2emb)
dist2emb<- gDistance(bart_utm,
sfhomes15_utm, byid=TRUE) /1000
# check output
nrow(dist2emb)
nrow(sfhomes15_utm)
head(dist2emb)
bart_stations_in_sf <-gIntersects(bart_utm, sfboundary)
# bart_stations_in_sf
bart_stations_in_sf <-gIntersects(bart_utm, sfboundary)
bart_stations_in_sf
sfbart_stations <-gIntersects(bart_utm, sfboundary, byid=TRUE)
# class(sfbart_stations)
# sfbart_stations
class(sfbart_stations)
sfbart_stations
bart_utm[as.vector(sfbart_stations),]$STATION
tmap_mode("view")
tm_shape(sfboundary) +
tm_polygons(col="beige", border.col="black") +
tm_shape(sfbart_utm) +
tm_dots(col="red")
sfbart_utm <- bart_utm[as.vector(sfbart_stations),]
tmap_mode("view")
tm_shape(sfboundary) +
tm_polygons(col="beige", border.col="black") +
tm_shape(sfbart_utm) +
tm_dots(col="red")
tmap_mode("plot")
sfbart_stations
bart_utm[sfbart_stations,]$STATION
as.vector(sfbart_stations)
readOGR(dsn = 'data', layer = 'sftracts_wpop.shp')
readOGR(dsn = 'data', layer = 'sftracts_wpop')
sftracts <- readOGR(dsn="./data", layer="sftracts_wpop")
class(sftracts)
proj4string(sftracts)
head(sftracts@data)
plot(sftracts)
homes_with_tracts <- over(sfhomes15_utm, sftracts)
homes_with_tracts <- over(sfhomes15_utm, sftracts)
# What is the CRS of the property data?
proj4string(sfhomes15_utm)
# What is the CRS of the census tracts?
proj4string(sftracts)
# Transform the CRS for tracts to be the same as that for sfhomes15_sp
sftracts_utm <- spTransform(sftracts, CRS(proj4string(sfhomes15_utm)))
# make sure the CRSs are the same
proj4string(sftracts_utm) == proj4string(sfhomes15_utm)
homes_with_tracts <- over(sfhomes15_utm, sftracts_utm)
homes_with_tracts <- over(sfhomes15_utm, sftracts_utm)
class(homes_with_tracts)
nrow(homes_with_tracts)
nrow(sftracts_utm)
nrow(sfhomes15_utm)
homes_with_tracts <- over(sfhomes15_utm, sftracts_utm)
class(homes_with_tracts)
nrow(homes_with_tracts)
nrow(sftracts_utm)
nrow(sfhomes15_utm)
head(homes_with_tracts)
head(sfhomes15_utm)
head(sfhomes15_utm@data)
head(homes_with_tracts)
sfhomes15_utm$home_geoid <- homes_with_tracts$GEOID
# Review and note the change
#head(sfhomes15_utm@data)
head(sfhomes)
head(sfhomes, 25)
head(iris)
med_hh_inc <- read.csv("data/sf_med_hh_income2015.csv", stringsAsFactors = F,
colClasses = c("character","numeric"))
head(med_hh_inc)
?merge
sfhomes15_utm <- sp::merge(sfhomes15_utm,
med_hh_inc, by.x="home_geoid", by.y="GEOID")
head(sfhomes15_utm@data, 2)  # take a look with View(sfhomes15_utm@data)
?merge
tmap_mode("view")
tm_shape(sfhomes15_utm) + tm_dots(col="medhhinc")
tracts_with_mean_val <- sp::aggregate(x = sfhomes15_utm["totvalue"],
by = sftracts_utm, FUN = mean)
?aggregate
tracts_with_mean_val <- aggregate(x = sfhomes15_utm["totvalue"],
by = sftracts_utm, FUN = mean)
class(tracts_with_mean_val)
head(tracts_with_mean_val@data)
nrow(tracts_with_mean_val) == nrow(sftracts_utm)
class(tracts_with_mean_val)
head(tracts_with_mean_val@data)
nrow(tracts_with_mean_val) == nrow(sftracts_utm)
sftracts_utm$mean_totvalue <- tracts_with_mean_val$totvalue
head(sftracts_utm@data) # check it
tm_shape(sftracts_utm) +
tm_polygons(col="mean_totvalue", border.col=NA)
tm_shape(sftracts_utm) +
tm_polygons(col="mean_totvalue", border.col=NA) +
tm_shape(sfhomes15_utm) + tm_dots()
bart_1km_buffer <- gBuffer(sfbart_utm, width=1000)
str(bart_1km_buffer)
tmap_mode("view")
tm_shape(bart_1km_buffer) + tm_polygons(col="red") +
tm_shape(sfbart_utm) + tm_dots()
bart_1km_buffer_byid <- gBuffer(sfbart_utm, width=1000, byid=TRUE)
tmap_mode("view")
tm_shape(bart_1km_buffer_byid) + tm_polygons(col="red") +
tm_shape(sfbart_utm) + tm_dots()
str(bart_1km_buffer_byid)
homes_near_bart <-  gIntersects(bart_1km_buffer, sfhomes15_utm, byid=TRUE)
class(homes_near_bart)
head(homes_near_bart)
dim(homes_near_bart)
# subset
sfhomes15_utm_near_bart <- sfhomes15_utm[as.vector(homes_near_bart),]
tm_shape(bart_1km_buffer) + tm_polygons(col="red") +
tm_shape(sfhomes15_utm_near_bart) + tm_dots()
library(sp)     # spatial objects and methods
library(rgdal)  # read/write from file; manage CRSs
library(rgeos)  # geometric operations
library(tmap)   # mapping spatial objects
library(raster) # reading in and operating on rasters
getwd()
getwd()
# Read in the 'sftracts_wpop' shapefile
tracts = readOGR('./data', 'sftracts_wpop')
# Read in from CSV file
print(list.files())
# Read in from CSV file
#print(list.files())
sfhomes <- read.csv('./data/sf_properties.csv',
stringsAsFactors = FALSE)
# subset the data
sfhomes15 <- subset(sfhomes, as.numeric(SalesYear) == 2015)
sfhomes15_sp <- sfhomes15  # Make a copy
# Make it spatial
coordinates(sfhomes15_sp) <- c('lon','lat')
class(sfhomes15_sp)
#Assign it a proj4string using the EPSG code
proj4string(sfhomes15_sp) <- CRS("+init=epsg:4326")
#Reproject to the tracts projection
#NOTE: We're overwriting the previous sfhomes15_sp object here! This is
#fine to do if we want, but we should always beware.
sfhomes15_sp = spTransform(sfhomes15_sp, CRS(proj4string(tracts)))
#check projection equality
proj4string(sfhomes15_sp) == proj4string(tracts)
head(sfhomes)
# Make it spatial
coordinates(sfhomes15_sp)# <- c('lon','lat')
#read in a Bay Area DEM (Digital Elevation Model)
#(from http://www.webgis.com/terr_pages/CA/dem1/sanfrancisco.html)
DEM = raster::raster('./data/san_francisco-e.DEM')
#plot it
plot(DEM)
DEM
tracts
str(DEM)
DEM@extent
DEM@crs
DEM@ncols
tracts@bbox
tracts@proj4string
DEM
DEM
(DEM@extent@xmax - DEM@extent@xmin) / DEM@ncols
(DEM@extent@ymax - DEM@extent@ymin) / DEM@nrows
DEM@data
DEM@data@values
DEM@data@inmemory
DEM@data@fromdisk
DEM[10:15, 20:30]
DEM[10:15, 20:30, drop = FALSE]
plot(DEM[10:15, 20:30, drop = FALSE])
DEM[,, drop = FALSE]
test = raster(matrix(DEM[,], ncol = ncol(DEM), byrow = TRUE))
test
test@data@values
test@data@fromdisk
test@data@inmemory
#check out its projection
proj4string(DEM)
#reproject tracts to our DEM projection
tracts_NAD = spTransform(tracts, CRS(proj4string(DEM)))
plot(DEM)
plot(tracts_NAD)
plot(DEM)
plot(tracts_NAD, add = T)
projectExtent(DEM, CRS(proj4string(tracts))
)
DEM_WGS = projectRaster(DEM, projectExtent(DEM, CRS(proj4string(tracts))))
# Now let's check equivalence
proj4string(tracts_NAD) == proj4string(DEM)
proj4string(DEM_WGS) == proj4string(tracts)
extent(tracts)
bbox(tracts)
class(extent(tracts))
# clip the WGS CRS version of the rasters to tracts
DEM_WGS_crop = crop(DEM_WGS, extent(tracts))
# Clip the NAD CRS version
DEM_crop = crop(DEM, extent(tracts_NAD))
plot(DEM_WGS_crop)
plot(tracts, add = T)
my_map <- tm_shape(DEM_WGS_crop) +
tm_raster() +
tm_shape(tracts) +
tm_borders() +
# Set mode to interactive
tmap_mode("view")
my_map <- tm_shape(DEM_WGS_crop) +
tm_raster() +
tm_shape(tracts) +
tm_borders() +
# Set mode to interactive
tmap_mode("view")
my_map
?mask
mask(DEM_WGS_crop, tracts)
mask_DEM = mask(DEM_WGS_crop, tracts)
plot(mask_DEM); plot(tracts, add = T)
?writeRaster
#write our reprojected, cropped data to the data directory, using the Geotiff format
#(and allow R to overwrite if file already exists)
writeRaster(DEM_WGS_crop, filename="./data/DEM_reproject_crop_TODAY.tif", format="GTiff", overwrite = T)
5 + 5
list.files('data')
# get the elevation for every cell in each of the census tracts
elev = extract(DEM_WGS_crop, tracts)
#what did that give us?
head(elev)
length(elev)
length(elev)
nrow(tracts)
mean_elev = lapply(elev, mean, na.rm = T)
head(mean_elev)
tracts$mean_elev = unlist(mean_elev)
head(tracts)
#what did we get?
elev_map <- tm_shape(tracts) +
tm_polygons(col = 'mean_elev') +
tm_layout("The pain of biking in SF, by census tract",
inner.margins=c(0,0,.1,0), title.size=4.8)
elev_map
elev = extract(DEM_WGS_crop, tracts, fun=mean)
#what did that give us?
head(elev)
class(elev)
#read in nlcd data
nlcd = raster('./data/nlcd2011_sf.tif')
#plot nlcd
plot(nlcd)
nlcd@data
nlcd@rotated
nlcd@rotation
?freq
freq(nlcd)
barplot(nlcd)
levels(nlcd)
nlcd@legend
#check projection equality
proj4string(nlcd) == proj4string(tracts)
#reproject
nlcd_WGS = projectRaster(nlcd, projectExtent(nlcd, CRS(proj4string(tracts))))
#check projection equality again
proj4string(nlcd_WGS) == proj4string(tracts)
#crop
nlcd_WGS_crop = crop(nlcd_WGS, extent(tracts))
nlcd_WGS_crop@legend
nlcd_WGS_crop@legend = nlcd@legend
nlcd_WGS_crop@legend
plot(nlcd_WGS_crop)
?reclassify
reclass_df <- c(0, 12, NA, # water will be set to NA (i.e. 'left out' of our analysis)
20, 21, 1, # we'll treat developed open space as greenspace, based on NLCD description
21, 30, 0, # developed and hardscape will have 0s
30, 32, NA,
40, Inf, 1) # greensapce will have 1s
reclass_df
reclass_m <- matrix(reclass_df, ncol = 3, byrow = TRUE)
reclass_m
nlcd_green <- reclassify(nlcd, reclass_m)
freq(nlcd_green)
barplot(nlcd_green)
plot(nlcd_green)
#extract the mean nlcd_simple values to tract polygons
greenspace = c(extract(nlcd_green, tracts, fun=mean))
greenspace
?extract
#extract the mean nlcd_simple values to tract polygons,
#this time setting na.rm to TRUE
greenspace = extract(nlcd_green, tracts, fun=mean, na.rm = T)
#and add to our tracts dataframe (which we can do because order is preserved)
tracts$prop_greenspace = greenspace
tm_shape(tracts) + tm_polygons(col = 'prop_greenspace')
library(ggplot2)
ggplot() + geom_polygon(aes(col = 'prop_greenspace'))
ggplot() + geom_polygon(data = tracts, aes(col = 'prop_greenspace'))
tm_shape(tracts) + tm_polygons(col = 'prop_greenspace')
tracts$prop_greenspace
tracts$prop_greenspace = tracts$prop_greenspace+0.00001
tm_shape(tracts) + tm_polygons(col = 'prop_greenspace')
tmap_mode('plot')
tm_shape(tracts) + tm_polygons(col = 'prop_greenspace')
tracts$prop_greenspace = tracts$prop_greenspace*100
tm_shape(tracts) + tm_polygons(col = 'prop_greenspace')
#extract the mean nlcd_simple values to tract polygons,
#this time setting na.rm to TRUE
greenspace = extract(nlcd_green, tracts, fun=mean, na.rm = T)
#aggregate totvalue to tracts
tracts_w_mean_val = aggregate(x = sfhomes15_sp['totvalue'], by = tracts, FUN = mean)
#use a quick tmap to check that it looks like sensible output
qtm(tracts_w_mean_val, fill = 'totvalue')
#and add the mean_val column to our tracts dataframe
tracts$mean_totvalue = tracts_w_mean_val$totvalue
mod = lm(mean_totvalue ~ mean_elev + prop_greenspace, data = tracts)
summary(mod)
#First, we'll take a random subset of our 2015 homes, so that our analysis doesn't take so long to compute.
sfhomes15_sample = sfhomes15_sp[sample(seq(nrow(sfhomes15_sp)), replace = FALSE, size = 2000), ]
#reproject
sfhomes15_utm <- spTransform(sfhomes15_sample, CRS("+init=epsg:26910"))
DEM_utm = projectRaster(DEM, projectExtent(DEM, CRS(proj4string(sfhomes15_utm))))
nlcd_green_utm = projectRaster(nlcd_green, projectExtent(nlcd_green, CRS(proj4string(sfhomes15_utm))))
#check that the projections are all good
proj4string(sfhomes15_utm) == proj4string(DEM_utm)
proj4string(sfhomes15_utm) == proj4string(nlcd_green_utm)
#create buffer
sfhomes15_utm_buff = gBuffer(sfhomes15_utm, width = 100, byid = T)
#sum the greenspace within the buffers
#NOTE: This will take a couple minutes to run...
greenspace_homes = extract(nlcd_green_utm, sfhomes15_utm_buff, fun = sum, na.rm = T)
#add that as a column in our sfhomes15_utm dataframe
sfhomes15_utm$greenspace = greenspace_homes
#extract the elevation to the homes
#NOTE: no need for fun or na.rm arguments here, because the homes
#and points, not polygons, so only a single cell will extract to each
elev_homes = extract(DEM_utm, sfhomes15_utm)
#add that as a column in our sfhomes15_utm dataframe too
sfhomes15_utm$elev = elev_homes
mod = lm(totvalue ~ elev + greenspace, data = sfhomes15_utm)
summary(mod)
#(from http://climate.calcommons.org/dataset/monthly-summertime-fog)
#(units are in average hours per day)
karl_files = unique(gsub('.aux.xml', '', list.files('./data/CalMnYr')))
karl_files = karl_files[grep('flcc', karl_files)]
karl_files
paste0('./data/CalMnYr/', karl_files)
karl <- stack(paste0('./data/CalMnYr/', karl_files))
# look at what we made
karl
#plot one
plot(karl[[7]])
plot(tracts, add = T)
#what's the projection?
proj4string(karl)
karl_WGS = projectRaster(karl, projectExtent(karl, CRS(proj4string(tracts))))
# check resultant CRS
proj4string(karl_WGS) == proj4string(tracts)
karl_WGS
# See the documentation!
?raster::brick
# Crop it to tracts
karl_WGS_crop = crop(karl_WGS, extent(tracts))
# now let's make our same plot again
par(mfrow = c(1,2))
plot(karl[[7]])
plot(tracts, add = T)
plot(karl_WGS_crop[[7]])
plot(tracts, add = T)
plot(karl[[1:4]])
karl[[1]]
karl[[1:4]]
# Mean values
mean_karl_WGS_crop = mean(karl_WGS_crop)
mean_karl_WGS_crop
plot(mean_karl_WGS_crop)
plot(tracts, add = T)
# This won't work
sd_karl_WGS_crop = sd(karl_WGS_crop)
sd_karl_WGS_crop = calc(karl_WGS_crop, sd)
#plot that too
par(mfrow = c(1,2))
plot(mean_karl_WGS_crop)
plot(tracts, add = T)
plot(sd_karl_WGS_crop)
plot(tracts, add = T)
tracts$mean_karl = extract(mean_karl_WGS_crop, tracts, mean)
# Linear regression model
mod = lm(mean_karl ~ mean_elev, data = tracts)
summary(mod)
?mask
