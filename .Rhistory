proj4string(sftracts)
#'
#' ## SF Census Tracts
## ------------------------------------------------------------------------
head(sftracts@data)
#'
#' ## Make a Quick Plot
#'
## ------------------------------------------------------------------------
plot(sftracts)
#'
#' ## Spatial Join
#'
#' A spatial join associates rows of data in one object with rows in another object based on the spatial relationship between the two objects.
#'
#' A spatial join is based on the comparison of two sets of geometries in the same coordinate space.
#'
#'  - This is also called a **spatial overlay**.
#'
#' The default spatial relationship is `intersects`
#'
#'
#'
#' ## In what census tract is each property located?
#'
#' We need to **spatially join** the `sftracts` and `sfhomes15_utm` to answer this.
#'
#' What spatial object are we joining data from? to?
#'
## ------------------------------------------------------------------------
par(mfrow=c(1,2))
plot(sftracts)
plot(sfhomes15_utm)
#'
#'
#' ## sp::over / rgeos::over
#'
#' Spatial overlay operations in R are implemented using `over`
#'
#' Simple point-in-polygon operations use `sp::over`
#'
#' More complex geometric comparisons use `rgeos::over`
#'
#' You need to have `rgeos` package installed!
#'
#' ## `over(x,y)`
#'
#' `over(x,y)`
#'
#' - for each feature in Layer X give me information about the first feature in Layer Y at the corresponding location.
#'
#' `over(x,y, returnList=TRUE)`  as:
#'
#' - for each feature in Layer X give me information about the all features in Layer Y at the corresponding location.
#'
#' See `?over` for details.
#'
#'
#' ## So here goes...
#'
#' *In what census tract is each SF property located?*
#'
## ---- eval=F-------------------------------------------------------------
## homes_with_tracts <- over(sfhomes15_utm, sftracts)
#'
#' ## Did it work?
#'
#' If not, why not?
#'
#'
#' # Coordinate reference systems (CRS) must be the same!
#'
#'
#' ## CRSs must be the same
#'
#' The `over` function, like almost all spatial analysis functions, requires that both data sets be spatial objects (they are) with the same coordinate reference system (CRS). Let's investigate
#'
## ---- eval=F-------------------------------------------------------------
## # What is the CRS of the property data?
## proj4string(sfhomes15_utm)
##
## # What is the CRS of the census tracts?
## proj4string(sftracts)
#'
#'
#' ## Transform the CRS
#'
## ------------------------------------------------------------------------
# Transform the CRS for tracts to be the same as that for sfhomes15_sp
sftracts_utm <- spTransform(sftracts, CRS(proj4string(sfhomes15_utm)))
# make sure the CRSs are the same
proj4string(sftracts_utm) == proj4string(sfhomes15_utm)
#'
#' Now let's try that overlay operation again
#'
#' ## Try 2
#'
#' In what tract is each SF property is located?
#'
#' - *Would a home be located in more than 1 tract?*
## ------------------------------------------------------------------------
homes_with_tracts <- over(sfhomes15_utm, sftracts_utm)
#'
#'
#'
#'
#' ## `over` output
#'
#' What is our output? Does it answer our question?
#'
#' What type of data object did the over function return?
#'
#' Do we need to add `returnList = TRUE`
#'
## ---- eval=F-------------------------------------------------------------
## homes_with_tracts <- over(sfhomes15_utm, sftracts_utm)
##
## class(homes_with_tracts)
## nrow(homes_with_tracts)
## nrow(sftracts_utm)
## nrow(sfhomes15_utm)
#'
#' ## Review the Over output
#'
#' What do we have here?
## ------------------------------------------------------------------------
homes_with_tracts <- over(sfhomes15_utm, sftracts_utm)
class(homes_with_tracts)
nrow(homes_with_tracts)
nrow(sftracts_utm)
nrow(sfhomes15_utm)
#'
#' ## Review the over output
## ------------------------------------------------------------------------
head(homes_with_tracts)
#'
#'
#'
#' ## `over` discussion
#'
#' Our output *homes_with_tracts* is a **data frame** that contains
#'
#' - the same number of rows as `sfhomes15_utm` - in same order
#' - the id of each property in `sfhomes15_utm`
#' - the data columns from `sftracts_utm@data` including the census tract id (GEOID)
#'
#' So we are close to answering our question.
#'
#' But for the data to be useful we need
#' - to add the `GEOID` column in `homes_with_tracts` to `sfhomes15_utm`
#'
#' ## Add the GEOID column
#'
#' *CAUTION: this only works because the data are in the same order!*
## ------------------------------------------------------------------------
sfhomes15_utm$home_geoid <- homes_with_tracts$GEOID
# Review and note the change
#head(sfhomes15_utm@data)
#'
#'
#' ## WOW
#'
#' Data linkage via space!
#'
#' The `over` operation gave us the census tract data info for each point in `sfhomes15_utm`
#'
#' We added the `GEOID` for each point to the `@data` slot of `sfhomes15_utm`
#'
#' We can now join `sfhomes15_utm` points by `GEOID` to any census variable, eg median household income, and then do an analysis of the relationship between, for example, property value and that variable.
#'
#' **How would we do that?**
#'
#' ## Read in the census data
#'
#' The `sf_med_hh_income2015.csv` file only has two columns: `GEOID` and `medhhinc`.
#'
#' Because `GEOIDs` can have leading zeros, we set the `colClasses` to make sure they are not stripped.
## ------------------------------------------------------------------------
med_hh_inc <- read.csv("data/sf_med_hh_income2015.csv", stringsAsFactors = F,
colClasses = c("character","numeric"))
head(med_hh_inc)
#'
#' ## Spatial*DataFrame to Data Frame Joins
#'
#' We can use `sp::merge` to join the `med_hh_inc` DF to the `sfhomes15_utm` SPDF.
#'
#' We should make sure that they share a column of common values - GEOID / home_geoid
#'
#' We use `sp:merge` not regular `merge` to maintain the integrity of the `sp` object
#'
#'   - i.e., make sure that the geometry and attribute data slots all stay aligned.
#'
#' ## Join by Attribute - a DF to a SPDF
#'
#' Join two data objects based on common values in a column.
#'
#' Use `sp:merge` to join a data frame to a spatial object with a data frames (`S*DF` objects)
#'
## ------------------------------------------------------------------------
sfhomes15_utm <- merge(sfhomes15_utm,
med_hh_inc, by.x="home_geoid", by.y="GEOID")
#'
#' **IMPORTANT:** DO NOT merge a data frame to the @data slot!
#'
#' - Join it to the SPDF!
#'
#' ## Take a look at output
#'
## ------------------------------------------------------------------------
head(sfhomes15_utm@data, 2)  # take a look with View(sfhomes15_utm@data)
#'
#'
#' ## Check the `sp::merge` results
#'
## ------------------------------------------------------------------------
tmap_mode("view")
tm_shape(sfhomes15_utm) + tm_dots(col="medhhinc")
#'
#' ## Reset plot mode
## ------------------------------------------------------------------------
tmap_mode("plot")
#'
#' ## The Census Tract Perspective
#'
#' We now know the tract for each property.
#'
#' Now let's think about this question from the tract perspective.
#'
#' Let's ask the question
#'
#' - What is the average propety value per tract?
#'
#'
#'
#' ## Non-Spatial Aggregation
#'
#' Since we joined GEOID to each property we can use the non-spatial `aggregate` function to compute the mean of totvalues for each GEOID.
#'
#' But let's use the `sp` aggregate function instead!
#'
#' It's actually more straight forward.
#'
#' ## sp::aggregate
#'
#' Aggregate data values in one spatial object by the geometry of another using the specified function.
#'
#' *What is the mean home value in each census tract?*
## ------------------------------------------------------------------------
tracts_with_mean_val <- aggregate(x = sfhomes15_utm["totvalue"],
by = sftracts_utm, FUN = mean)
#'
#' Wow, so simple. What does that give us?
#'
#'
#' ## Examine output of `sp::aggregate`
#'
## ------------------------------------------------------------------------
class(tracts_with_mean_val)
head(tracts_with_mean_val@data)
nrow(tracts_with_mean_val) == nrow(sftracts_utm)
#'
#' ## sp::aggregate output
#'
#' `sp::aggregate` returned a SpatialPolygonsDataFrame
#'
#' The SPDF has the same geometry as `sftracts_utm`
#'
#' But the `tracts_with_mean_val@data` slot only contains the mean totvalue for each tract.
#'
#' To make these data more useful, let's add this value to `sftracts_utm`
#'
#' ##
#'
#' This only works because their are the same number of elements both @data slots and they are in the same order!
## ------------------------------------------------------------------------
sftracts_utm$mean_totvalue <- tracts_with_mean_val$totvalue
head(sftracts_utm@data) # check it
#'
#' ## Map it
#'
#' Make a map of the results to make sure they seem reasonable.
#'
#' First, set `tmap` to interactive mode
## ------------------------------------------------------------------------
tmap_mode("view")
#'
#' # Map the results
#'
## ------------------------------------------------------------------------
tm_shape(sftracts_utm) +
tm_polygons(col="mean_totvalue: ", border.col=NA)
#'
#' ## Why no values for some tracts?
## ------------------------------------------------------------------------
tm_shape(sftracts_utm) +
tm_polygons(col="mean_totvalue", border.col=NA) +
tm_shape(sfhomes15_utm) + tm_dots()
#'
#' # Distance
#'
#' ## Distance queries
#'
#' Many methods of spatial analysis are based on distance queries.
#'
#' For example, point pattern analysis considers the distance between features to determine whether or not they are clustered.
#'
#' We can also use distance as a way to select features spatially.
#'
#' ## Proximity
#'
#' The other side of distance!
#'
#' What properties are within walking distance of BART?
#'
#' ## Selecting by Distance
#'
#' In order to select properties with 1KM of BART
#' - create a 1KM radius buffer polygon around each BART point
#'
#' We then do a point-in-polygon operation to either count the number of properties within the buffer or compute the mean totvalue.
#'
#' ## rgeos
#'
#' `rgeos` is the muscle for
#'
#' - creating new geometries from exisiting ones
#' - calculating spatial metrics like area, length, distance
#' - calculating the spatial relationship between two geometries.
#'
#' We can use the `rgeos::gBuffer` function to create our buffer polygon
#'
#' ## Creating Buffers
#'
#' The `rgeos::gBuffer` function takes as input a spatial object or objects to buffer and a buffer distance.
#'
#' Let's assume 1KM is standard walking distance.
## ------------------------------------------------------------------------
bart_1km_buffer <- gBuffer(sfbart_utm, width=1000)
#'
#' ## Map the Buffer
## ------------------------------------------------------------------------
tmap_mode("view")
tm_shape(bart_1km_buffer) + tm_polygons(col="red") +
tm_shape(sfbart_utm) + tm_dots()
#'
#' ## Try This
#'
#' How does this differ when we add `byid=TRUE`
## ------------------------------------------------------------------------
bart_1km_buffer_byid <- gBuffer(sfbart_utm, width=1000, byid=TRUE)
tmap_mode("view")
tm_shape(bart_1km_buffer_byid) + tm_polygons(col="red") +
tm_shape(sfbart_utm) + tm_dots()
#'
#' ## What sfhomes are within 1km of any bart station?
#'
#' What operation could we use?
#'
#' Which buffer polygons?
#'
#' ##  What sfhomes are within 1km of any bart station?
#'
#' Why `byid=TRUE`
#'
#' What is the output?
## ------------------------------------------------------------------------
homes_near_bart <-  gIntersects(bart_1km_buffer, sfhomes15_utm, byid=TRUE)
class(homes_near_bart)
head(homes_near_bart)
#'
#' ## Select the sfhomes15_utm points in the buffer
#'
## ------------------------------------------------------------------------
# subset
sfhomes15_utm_near_bart <- sfhomes15_utm[as.vector(homes_near_bart),]
#'
#' ## Map it
## ------------------------------------------------------------------------
tm_shape(bart_1km_buffer) + tm_polygons(col="red") +
tm_shape(sfhomes15_utm_near_bart) + tm_dots()
#'
#'
#' ## Questions
#'
#'
#' ## Summary
#'
#' That was a whirlwind tour of just some of the methods of spatial analysis.
#'
#' There was a lot we didn't and can't cover.
#'
#' `sf` package is emerging and will eclipse `sp`
#'
#' Raster data is a another major topic!
#' - but the `raster` package is the key
#'
#'
#' ## Selected  References & Tutorials
#'
#' Introductory Tutorials
#'
#' - [Spatial Data in R tutorial](https://cengel.github.io/rspatial)
#' - [NEON Spatial Data tutorials](http://neondataskills.org/tutorial-series/)
#' - [GIS in R](http://www.nickeubank.com/gis-in-r)
#'
#' Geodata Visualization emphasis
#'
#' - [Tmap in a Nutshell](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-nutshell.html)
#' - [Intro to visualizing Spatial Data in R](https://github.com/Robinlovelace/Creating-maps-in-R)
#' - [RStudio Leaflet in R tutorial](https://rstudio.github.io/leaflet)
#' - [Blog on mapping census data in R](http://zevross.com/blog/2015/10/14/manipulating-and-mapping-us-census-data-in-r-using-the-acs-tigris-and-leaflet-packages-3/)
#'
#' ## Selected  References & Tutorials
#'
#' Deep dive Tutorials that include spatial analysis
#'
#' - [An Introduction to Spatial Data Analysis and Visualisation in R](https://data.cdrc.ac.uk/tutorial/an-introduction-to-spatial-data-analysis-and-visualisation-in-r)
#' - [Intro to GIS and Spatial Analysis (see appendices)](https://mgimond.github.io/Spatial/index.html)
#' - [Spatial Data Analysis and Modeling in R](http://www.rspatial.org/index.html)
#' - [Geocomputation in R (featuring sf Package)](http://robinlovelace.net/geocompr/ )
#' - [Weight Spatial Polygon Overlay tutorial, aka areal interpolation](http://rstudio-pubs-static.s3.amazonaws.com/6577_3b66f8d8f4984fb2807e91224defa854.html)
#'
#'
#' CRAN Spatial Packages
#'
#' - [CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html)
#'
#' ## Output code to script
#'
## ---- eval=F-------------------------------------------------------------
## library(knitr)
## purl("r-geospatial-workshop-feb2018-pt2.Rmd", output = "scripts/r-geospatial-workshop-feb2018-pt2.r", documentation = 2)
#'
#'
homes_near_bart <-  gIntersects(bart_1km_buffer, sfhomes15_utm, byid=TRUE)
head(homes_near_bart)
nrow(homes_near_bart)
head(bart_1km_buffer@data)
head(bart_1km_buffer)
head(sfbart_utm@data)
sfbart_utm@data
?gBuffer
bart_1km_buffer_byid <- gBuffer(sfbart_utm, width=1000, byid=TRUE, id="STATION")
head(homes_near_bart)?gIntersects()
?gIntersects
homes_near_bart <-  gIntersects(bart_1km_buffer, sfhomes15_utm, byid=TRUE)
homes_near_bart
head(homes_near_bart)
nrow(homes_near_bart)
homes_near_bart2 <-  gIntersects(sfhomes15_utm,bart_1km_buffer, byid=TRUE)
head(homes_near_bart2)
dim(homes_near_bart2)
head(homes_near_bart2)
class(homes_near_bart2)
dim(homes_near_bart2)
homes_near_bart3 <-  over(sfhomes15_utm,bart_1km_buffer, returnList =TRUE)
homes_near_bart4 <-  over(bart_1km_buffer,sfhomes15_utm, returnList =TRUE)
head(homes_near_bart3)
dim(homes_near_bart3)
dim(homes_near_bart4)
head(homes_near_bart4)
class(homes_near_bart4)
?over
homes_near_bart3 <-  over(sfhomes15_utm,bart_1km_buffer)
head(homes_near_bart3)
nrow(homes_near_bart3)
length(homes_near_bart3)
homes_near_bart3 <-  over(sfhomes15_utm,bart_1km_buffer, returnList = T)
length(homes_near_bart3)
head(homes_near_bart3)
head(homes_near_bart3)
?gBuffer
class(bart_1km_buffer)
class(bart_1km_buffer_byid)
head(bart_1km_buffer_byid@data)
homes_near_bart3 <-  over(sfhomes15_utm,bart_1km_buffer_byid)
head(homes_near_bart)
nrow(homes_near_bart3)
class(homes_near_bart3)
View(homes_near_bart3)
homes_near_bart3 <-  over(sfhomes15_utm,bart_1km_buffer_byid, returnList = T)
View(homes_near_bart[1]@data)
View(homes_near_bart[1])
View(homes_near_bart[[1])
View(homes_near_bart[[1]])
View(homes_near_bart[5])
View(homes_near_bart[5]@data)
View(homes_near_bart3[5])
homes_near_bart4 <-  over(bart_1km_buffer_byid,sfhomes15_utm, returnList =TRUE)
homes_near_bart[1]
homes_near_bart4[1]
nrow(homes_near_bart4[1])
length(homes_near_bart4[1])
View(homes_near_bart4[1])
nrow(homes_near_bart4[1]@data)
nrow(homes_near_bart4[[1]])
nrow(homes_near_bart4[[2]])
nrow(homes_near_bart4[[3]])
nrow(homes_near_bart4[[4]])
nrow(homes_near_bart4[[5]])
nrow(homes_near_bart4[[6]])
nrow(homes_near_bart4[[7]])
nrow(homes_near_bart4[[8]])
nrow(homes_near_bart4[[9]])
View(homes_near_bart4[1])
View(homes_near_bart4[2])
View(sfbart_stations)
View(sfbart_utm@data)
purl("r-geospatial-workshop-pt1.Rmd",
output = "scripts/r-geospatial-workshop-pt1-may2018.R", documentation = 1)
purl("r-geospatial-workshop-pt2.Rmd", output = "scripts/r-geospatial-workshop-pt2-May-2018.R", documentation = 2)
purl("r-geospatial-workshop-pt2.Rmd", output = "scripts/r-geospatial-workshop-pt2-May-2018.R", documentation = 2)
